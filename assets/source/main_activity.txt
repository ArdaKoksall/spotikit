package X_PACKAGE_NAME

import android.content.Context
import android.content.Intent
import android.content.SharedPreferences
import android.util.Base64
import android.util.Log
import androidx.annotation.NonNull
import androidx.lifecycle.lifecycleScope
import com.spotify.android.appremote.api.ConnectionParams
import com.spotify.android.appremote.api.Connector
import com.spotify.android.appremote.api.SpotifyAppRemote
import com.spotify.sdk.android.auth.AuthorizationClient
import com.spotify.sdk.android.auth.AuthorizationRequest
import com.spotify.sdk.android.auth.AuthorizationResponse
import io.flutter.embedding.android.FlutterActivity
import io.flutter.embedding.engine.FlutterEngine
import io.flutter.plugin.common.MethodChannel
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import okhttp3.FormBody
import okhttp3.OkHttpClient
import okhttp3.Request
import org.json.JSONObject

class MainActivity: FlutterActivity() {

    companion object {
        private const val CHANNEL_NAME = "com.ardakoksal.kevin/spotify"
        private val TAG = "MainActivity"

        private const val CLIENT_ID = "X_USER_CLIENT_ID"
        private const val REDIRECT_URI = "X_USER_REDIRECT_URI"
        private const val CLIENT_SECRET = "X_USER_CLIENT_SECRET"
        private const val SPOTIFY_SCOPE = "X_USER_SCOPE"
        private const val AUTH_REQUEST_CODE = 1337

        // --- SharedPreferences Keys ---
        private const val PREFS_NAME = "SpotifyTokenPrefs"
        private const val KEY_ACCESS_TOKEN = "access_token"
        private const val KEY_REFRESH_TOKEN = "refresh_token"
        private const val KEY_TOKEN_EXPIRES_AT = "token_expires_at"
    }

    private var spotifyAppRemote: SpotifyAppRemote? = null
    private val httpClient: OkHttpClient by lazy { OkHttpClient() }
    private lateinit var sharedPreferences: SharedPreferences
    private lateinit var channel: MethodChannel

    // In-memory token cache
    private var accessToken: String? = null
    private var refreshToken: String? = null
    private var tokenExpiresAt: Long = 0

    override fun configureFlutterEngine(@NonNull flutterEngine: FlutterEngine) {
        super.configureFlutterEngine(flutterEngine)

        sharedPreferences = getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
        loadTokensFromPrefs()

        channel = MethodChannel(flutterEngine.dartExecutor.binaryMessenger, CHANNEL_NAME)
        channel.setMethodCallHandler { call, result ->
            when (call.method) {
                "connectToSpotify" -> connectToSpotify(result)
                "authenticateSpotify" -> authenticateSpotify(result)
                "getAccessToken" -> getAccessToken(result)
                "refreshToken" -> refreshToken(result)
                "play" -> {
                    val spotifyUri = call.argument<String>("spotifyUri")
                    if (spotifyUri != null) play(spotifyUri, result)
                    else result.error("INVALID_ARGUMENT", "spotifyUri cannot be null", null)
                }
                "pause" -> pause(result)
                "resume" -> resume(result)
                "disconnect" -> disconnect(result)
                "getTrackInfo" -> getTrackInfo(result)
                "logout" -> logout(result)
                "skipTrack" -> skipTrack(result)
                "previousTrack" -> previousTrack(result)
                else -> result.notImplemented()
            }
        }
    }

    /**
     * Handles the result from the Spotify Login Activity.
     */
    override fun onActivityResult(requestCode: Int, resultCode: Int, intent: Intent?) {
        super.onActivityResult(requestCode, resultCode, intent)

        if (requestCode == AUTH_REQUEST_CODE) {
            val response = AuthorizationClient.getResponse(resultCode, intent)
            when (response.type) {
                AuthorizationResponse.Type.CODE -> {
                    Log.d(TAG, "Successfully received Spotify auth code.")
                    exchangeCodeForTokens(response.code)
                }
                AuthorizationResponse.Type.ERROR -> {
                    Log.e(TAG, "Spotify auth error: ${response.error}")
                    channel.invokeMethod("spotifyAuthFailed", mapOf("error" to response.error))
                }
                else -> {
                    Log.w(TAG, "Spotify auth flow cancelled by user.")
                    channel.invokeMethod("spotifyAuthFailed", mapOf("error" to "cancelled"))
                }
            }
        }
    }

    /**
     * Disconnects from the Spotify App Remote when the activity is stopped
     * to free up resources.
     */
    override fun onStop() {
        super.onStop()
        spotifyAppRemote?.let {
            if (it.isConnected) SpotifyAppRemote.disconnect(it)
        }
    }

    // ========== Method Channel Implementations ==========

    /**
     * Connects to the Spotify App Remote.
     */
    private fun connectToSpotify(result: MethodChannel.Result) {
        if (spotifyAppRemote?.isConnected == true) {
            result.success("Already connected")
            return
        }

        val connectionParams = ConnectionParams.Builder(CLIENT_ID)
            .setRedirectUri(REDIRECT_URI)
            .showAuthView(true)
            .build()

        val connectionListener = object : Connector.ConnectionListener {
            override fun onConnected(appRemote: SpotifyAppRemote) {
                spotifyAppRemote = appRemote
                Log.d(TAG, "Spotify App Remote connected.")
                result.success("Connected")
            }

            override fun onFailure(throwable: Throwable) {
                Log.e(TAG, "Spotify connection failed: ${throwable.message}", throwable)
                result.error("CONNECTION_ERROR", "Could not connect to Spotify.", throwable.message)
            }
        }
        SpotifyAppRemote.connect(this, connectionParams, connectionListener)
    }

    /**
     * Starts the Spotify authentication flow to get an authorization code.
     * The result is handled in onActivityResult.
     */
    private fun authenticateSpotify(result: MethodChannel.Result) {
        val request = AuthorizationRequest.Builder(CLIENT_ID, AuthorizationResponse.Type.CODE, REDIRECT_URI)
            .setScopes(SPOTIFY_SCOPE.split(" ").toTypedArray())
            .build()
        AuthorizationClient.openLoginActivity(this, AUTH_REQUEST_CODE, request)
        result.success("Authentication flow started")
    }

    /**
     * Retrieves a valid access token. If the current one is expired, it attempts to refresh it.
     */
    private fun getAccessToken(result: MethodChannel.Result) {
        if (accessToken != null && System.currentTimeMillis() < tokenExpiresAt) {
            result.success(accessToken)
        } else if (refreshToken != null) {
            Log.d(TAG, "Access token expired. Refreshing...")
            refreshToken(result) // This will eventually call result.success/error
        } else {
            result.error("NO_TOKEN", "No valid token available. Please authenticate.", null)
        }
    }

    /**
     * Disconnects from the Spotify App Remote, clears all tokens, and purges saved preferences.
     */
    private fun logout(result: MethodChannel.Result) {
        disconnect(object : MethodChannel.Result { // Use a proxy result to chain actions
            override fun success(res: Any?) {
                accessToken = null
                refreshToken = null
                tokenExpiresAt = 0
                sharedPreferences.edit().clear().apply()
                Log.d(TAG, "User logged out and all data cleared.")
                result.success("Logged out successfully")
            }
            override fun error(code: String, msg: String?, details: Any?) { result.error(code, msg, details) }
            override fun notImplemented() { result.notImplemented() }
        })
    }

    // ========== Playback Control ==========

    private fun play(spotifyUri: String, result: MethodChannel.Result) {
        performActionIfConnected(result) { remote ->
            remote.playerApi.play(spotifyUri)
                .setResultCallback { result.success("Playback started for $spotifyUri") }
                .setErrorCallback { result.error("PLAY_ERROR", it.message, null) }
        }
    }

    private fun pause(result: MethodChannel.Result) {
        performActionIfConnected(result) { remote ->
            remote.playerApi.pause()
                .setResultCallback { result.success("Playback paused") }
                .setErrorCallback { result.error("PAUSE_ERROR", it.message, null) }
        }
    }

    private fun resume(result: MethodChannel.Result) {
        performActionIfConnected(result) { remote ->
            remote.playerApi.resume()
                .setResultCallback { result.success("Playback resumed") }
                .setErrorCallback { result.error("RESUME_ERROR", it.message, null) }
        }
    }

    private fun skipTrack(result: MethodChannel.Result) {
        performActionIfConnected(result) { remote ->
            remote.playerApi.skipNext()
                .setResultCallback { result.success("Skipped to next track") }
                .setErrorCallback { result.error("SKIP_ERROR", it.message, null) }
        }
    }

    private fun previousTrack(result: MethodChannel.Result) {
        performActionIfConnected(result) { remote ->
            remote.playerApi.skipPrevious()
                .setResultCallback { result.success("Skipped to previous track") }
                .setErrorCallback { result.error("PREVIOUS_ERROR", it.message, null) }
        }
    }

    private fun getTrackInfo(result: MethodChannel.Result) {
        performActionIfConnected(result) { remote ->
            remote.playerApi.playerState.setResultCallback { playerState ->
                result.success(mapOf(
                    "artist" to playerState.track.artist.name,
                    "name" to playerState.track.name,
                    "uri" to playerState.track.uri,
                    "isPaused" to playerState.isPaused
                ))
            }
        }
    }

    private fun disconnect(result: MethodChannel.Result) {
        spotifyAppRemote?.let {
            if (it.isConnected) {
                SpotifyAppRemote.disconnect(it)
                spotifyAppRemote = null
                Log.d(TAG, "Spotify App Remote disconnected.")
                result.success("Disconnected")
            } else {
                result.success("Already disconnected")
            }
        } ?: result.success("Not connected, no action taken")
    }

    // ========== Token Handling ==========

    private fun exchangeCodeForTokens(code: String) {
        lifecycleScope.launch(Dispatchers.IO) {
            try {
                val responseBody = makeTokenRequest(
                    FormBody.Builder()
                        .add("grant_type", "authorization_code")
                        .add("code", code)
                        .add("redirect_uri", REDIRECT_URI)
                        .build()
                )

                if (responseBody != null) {
                    processTokenResponse(responseBody)
                    Log.d(TAG, "Successfully exchanged code for tokens.")
                    withContext(Dispatchers.Main) {
                        channel.invokeMethod("spotifyAuthSuccess", mapOf("accessToken" to accessToken))
                    }
                } else {
                    throw Exception("Token exchange response was null or unsuccessful")
                }
            } catch (e: Exception) {
                Log.e(TAG, "Error exchanging code for tokens", e)
                withContext(Dispatchers.Main) {
                    channel.invokeMethod("spotifyAuthFailed", mapOf("error" to "token_exchange_failed", "message" to e.message))
                }
            }
        }
    }

    private fun refreshToken(result: MethodChannel.Result) {
        val currentRefreshToken = refreshToken
        if (currentRefreshToken == null) {
            result.error("NO_REFRESH_TOKEN", "No refresh token available.", null)
            return
        }

        lifecycleScope.launch(Dispatchers.IO) {
            try {
                val responseBody = makeTokenRequest(
                    FormBody.Builder()
                        .add("grant_type", "refresh_token")
                        .add("refresh_token", currentRefreshToken)
                        .build()
                )

                if (responseBody != null) {
                    processTokenResponse(responseBody)
                    Log.d(TAG, "Successfully refreshed tokens.")
                    withContext(Dispatchers.Main) {
                        result.success(accessToken)
                    }
                } else {
                    throw Exception("Token refresh response was null or unsuccessful")
                }
            } catch (e: Exception) {
                Log.e(TAG, "Error refreshing token", e)
                withContext(Dispatchers.Main) {
                    result.error("REFRESH_ERROR", "Failed to refresh token", e.message)
                }
            }
        }
    }

    private fun makeTokenRequest(formBody: FormBody): String? {
        val credentials = "$CLIENT_ID:$CLIENT_SECRET"
        val encodedCredentials = Base64.encodeToString(credentials.toByteArray(), Base64.NO_WRAP)

        val request = Request.Builder()
            .url("https://accounts.spotify.com/api/token")
            .addHeader("Authorization", "Basic $encodedCredentials")
            .post(formBody)
            .build()

        httpClient.newCall(request).execute().use { response ->
            if (!response.isSuccessful) {
                Log.e(TAG, "Token request failed with code ${response.code}: ${response.body?.string()}")
                return null
            }
            return response.body?.string()
        }
    }

    private fun processTokenResponse(responseBody: String) {
        val jsonObject = JSONObject(responseBody)
        accessToken = jsonObject.getString("access_token")
        // Spotify may or may not return a new refresh token. If it doesn't, keep the old one.
        refreshToken = jsonObject.optString("refresh_token", refreshToken)
        val expiresIn = jsonObject.getInt("expires_in")
        tokenExpiresAt = System.currentTimeMillis() + (expiresIn * 1000L)

        saveTokensToPrefs()
    }

    // ========== Persistence ==========

    private fun saveTokensToPrefs() {
        with(sharedPreferences.edit()) {
            putString(KEY_ACCESS_TOKEN, accessToken)
            putString(KEY_REFRESH_TOKEN, refreshToken)
            putLong(KEY_TOKEN_EXPIRES_AT, tokenExpiresAt)
            apply()
        }
        Log.d(TAG, "Tokens saved to SharedPreferences.")
    }

    private fun loadTokensFromPrefs() {
        accessToken = sharedPreferences.getString(KEY_ACCESS_TOKEN, null)
        refreshToken = sharedPreferences.getString(KEY_REFRESH_TOKEN, null)
        tokenExpiresAt = sharedPreferences.getLong(KEY_TOKEN_EXPIRES_AT, 0)
        if (accessToken != null) {
            Log.d(TAG, "Tokens loaded from SharedPreferences.")
        }
    }

    // ========== Helpers ==========

    /**
     * A helper to execute an action only if the Spotify App Remote is connected.
     */
    private fun performActionIfConnected(result: MethodChannel.Result, action: (SpotifyAppRemote) -> Unit) {
        val remote = spotifyAppRemote
        if (remote?.isConnected == true) {
            action(remote)
        } else {
            result.error("NOT_CONNECTED", "Spotify App Remote is not connected.", null)
        }
    }
}